#!/bin/bash
# Build a DICOM database with datalad
OPTIONS="$@"
VERSION=0.0.1
# Define Function
## Parse Input Arguments
function fetchdicom_parseoptions(){
	clear && printf '\e[3J'
	fetchdicom_declarations
	while :; do
		case ${1} in
			-h|--help)
			fetchdicom_help
			exit
			;;
			-prv|--private)
				private='omit identifiers'
			;;
			install)
				INSTALL='true'
			;;
			config)
				CONFIG='true'
				if [ -n "${2}" ]; then
					DATABASE=${2}
				else
					if [ -d ${DATABASEDIR} ] && [ $(find ${DATABASEDIR} -name '*.config' | sed 's|/| |g' | awk '{print $NF}' | sed 's|.config||g' | wc -l) -gt 1 ]; then
						echo -e "\n${YELLOW}WARNING: Multiple Databases Detected${NC}\n\n\t..which database would you like to configure?\n" >&2
						echo -e "$(find ${DATABASEDIR} -name '*.config' | sed 's|/| |g' | awk '{print $NF}' | sed 's|.config||g' | nl)" && echo ''
						read -p "Enter exact name or (n)ew to create new database >> " response
						[ "${response}" = 'n' ] || [ "${response}" = 'new' ] && fetchdicom_config.database
						DATABASE=$(find ${DATABASEDIR} -name "${response}.config" | sed 's|/| |g' | awk '{print $NF}' | sed 's|.config||g')
						[ ! "${DATABASE}" ] && echo -e "${YELLOW}Entered response, does not match existing database names.. " >&2 && read -p "‚èé   to try again, ctrl + c to quit" && fetchdicom_run
					elif [ $(find ${DATABASEDIR} -name '*.config' | sed 's|/| |g' | awk '{print $NF}' | sed 's|.config||g' | wc -l) -eq 1 ]; then
						DATABASE=$(find ${DATABASEDIR} -name '*.config' | sed 's|/| |g' | awk '{print $NF}' | sed 's|.config||g')
					else
						fetchdicom_config.database
					fi
					shift
				fi				
			;;			
			from)
				if [ -n "${2}" ]; then
					DATABASE=${2}
					RETRIEVE='true'
					shift
				else
					echo -e "\n${RED}ERROR: ${NC}fetch dicom from where? missing name of database.. example) ${0##*/} from dicomdb.cfmi\n" >&2
					EXIT=1 && fetchdicom_exit
				fi
			;;
			create)
				if [ -n "${2}" ]; then
					DATABASE=${2}
					CREATE='true'
					shift
				else
					echo -e "\n${RED}ERROR: ${NC}create what? missing name of database.. example) ${0##*/} create mydicomdb\n" >&2
					EXIT=1 && fetchdicom_exit
				fi				
			;;
			update)
				UPDATE='true'
				if [ -n "${2}" ]; then
					DATABASE=${2}
					update='true'
					shift
				fi				
			;;			
	        -?*)
	            printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
	        ;;
	        *)
	            break
	    esac
	    shift
	done
}
## Check for dependencies
function fetchdicom_dependencies(){
	# Check for macOS dependencies
    if [ $(uname) = 'Darwin' ]; then
    	# Check for macOS package manager
    	if [ -z $(which brew) ]; then
	    	echo -e "\n\t${YELLOW}WARNING: Missing Program${NC}\tPackage Manager Homebrew does not appear to be properly installed..\n\n\tWould you like to install Homebrew, the missing package manager for OS X (highly recommended) (y/n)" >&2 && read response
	    	if [ "${response}" = "y" ] || [ "${response}" = "Y" ]; then
	            if ruby -e "$(curl -fsSL https://raw.githubSERVERUSERcontent.com/Homebrew/install/master/install)"; then
	            	echo ''
	            else
	            	echo -e "${RED}Failed Installation :: ${GREEN}homebrew" >&2
	            	EXIT=1
	            fi
	        elif [ "${response}" = "n" ] || [ "${response}" = "N" ]; then
	        	EXIT=1
	        else
	        	fetchdicom_dependencies
	        fi
	    fi
        # Loop and check for missing software that can be installed with homebrew
        local dependencies="dcm2niix git git-crypt git-annex parallel sshfs tree" && local missing=""
        for dependency in ${dependencies}; do
        	if [ -z "$(which ${dependency})" ]; then
        		missing="${missing} ${dependency}"
        	fi
        done
        # Now install the missing software
        if [ "${missing}" ]; then
        	echo -e "${YELLOW}Missing Software :: ${GREEN}${missing}" >&2
        	if brew install ${missing}; then
        		echo ''
        	else
        		echo -e "${RED}Failed Installation :: ${GREEN}${missing}" >&2
        		EXIT=1
        	fi
        fi
        # Check if osxfuse is installed
        if [ -z $(brew cask list | grep 'osxfuse') ]; then
        	echo -e "${YELLOW}Missing Software :: ${GREEN}osxfuse" >&2
        	if brew cask install osxfuse; then
        		echo ''
        	else
        		echo -e "${RED}Failed Installation :: ${GREEN}osxfuse" >&2
        		EXIT=1
        	fi
        fi                
        # Check if pip is installed, if not then install anaconda
        if [ -z $(which pip) ]; then
        	echo -e "${YELLOW}Missing Software :: ${GREEN}pip, anaconda" >&2
        	if brew install caskroom/cask/anaconda && export PATH=/usr/local/anaconda3/bin:"$PATH"; then
        		echo ''
        	else
        		echo -e "${RED}Failed Installation :: ${GREEN}anaconda" >&2
        		EXIT=1
        	fi
        fi
        # Install datalad - we use this to version control the database
        if [ -z $(which datalad) ]; then
        	echo -e "${YELLOW}Missing Software :: ${GREEN}datalad" >&2
        	if pip install datalad; then
        		echo ''
        	else
        		echo -e "${RED}Failed Installation :: ${GREEN}pip" >&2
        		EXIT=1
        	fi
        fi
        # Install dcm2bids
        if [ -z $(which dcm2bids) ]; then
        	echo -e "${YELLOW}Missing Software :: ${GREEN}dcm2bids" >&2
			if git clone https://github.com/cbedetti/Dcm2Bids.git ${HOME}/Dcm2Bids; then
				echo ''
			else
				EXIT=1 && fetchdicom_exit
			fi
			cd ${HOME}/Dcm2Bids 
			if pip install .; then
				cd ${CWD}
				echo ''
			else
				echo -e "${RED}Failed Installation :: ${GREEN}dc2mbids" >&2
				EXIT=1
			fi
		fi        
    elif [ "$(uname)" = 'Linux' ]; then
  #   	if [ -z $(which dcm2niix) ]; then
  #   		git clone https://github.com/rordenlab/dcm2niix.git ${HOME}/dcm2niix
  #   		cd ${HOME}/dcm2niix && mkdir build && cd build && cmake .. && make
		# fi    		
		if [ -z $(which dcm2niix) ] || [ -z $(which tree) ] || [ -z $(which git) ] || [ -z $(which git-annex) ] || [ -z $(which git-crypt) ] || [ -z $(which parallel) ] || [ -z $(which datalad) ] || [ -z $(which dcm2bids) ]; then
			echo -e "${YELLOW}Install of packages dcm2biix, tree, git, git-annex, git-crypt, parallel, datalad, dcm2bids not supported on LINUX ${NC}\n\t- Please install these packages on your own\n\t- You can contribute to this repo by submitting a pull request for this missing feature" >&2
			EXIT=1    	
		fi
    else
    	echo -e "${BRED}Error: ${NC}unrecognized OS ${YELLOW}$(uname)" >&2
    	EXIT=1
    fi
    echo '  ‚öôÔ∏è ---> dependency check complete '$EXIT
    fetchdicom_exit	
}
# Define Function
## Run sequence of functions for getting data
function fetchdicom_run(){
	# Parse Options
	fetchdicom_parseoptions "${OPTIONS}"
	# Install all dependencies, set up ram disk and initialize configuration
	[ "${INSTALL}" ] && fetchdicom_install
	[ "${CONFIG}" ] && fetchdicom_config
	# [ "${BUILD}" ] && fetchdicom_createdb
	# [ "${UPDATE}" ] && fetchdicom_updatedatabase
}
# Define Function
## Check for exit signal
function fetchdicom_exit(){
	if [ ${EXIT} ]; then
		cd ${DATABASEDIR} && datalad add * && datalad save && cd ${CWD}
		echo -e "\n${RED}...exiting\n"
		exit
	fi
}
# Define Function
function fetchdicom_declarations(){
	CWD=$(pwd) # Current Working Directory @ Time of Execution
	RED='\033[0;31m' && BRED='\033[1;31m' && YELLOW='\033[1;33m' && GREEN='\033[1;32m' && BLUE='\033[1;34m' && GREY='\033[1;37m' NC='\033[0m' # Colors
	# Database meta-data settings
	[ ! ${DATABASEDIR} ] && DATABASEDIR=${HOME}'/.dicom.db'
	[ ! ${DATABASE_SHARETYPE} ] && DATABASE_SHARETYPE='group'
	DATABASECONFIGFILE=${DATABASEDIR}/${DATABASE}.config
	# Remote server settings
	# [ ! ${SERVERUSER} ] && SERVERUSER=''
	# [ ! ${SERVER} ] && SERVER=''
	# DICOM DB settings
	[ ${SERVERUSER} ] && [ ${SERVER} ] && DICOMDATADIR=${DATABASEDIR}/${SERVERUSER}@${SERVER}.DICOMS
	[ ! ${DCMPARENTDIR} ] && DCMPARENTDIR='.SER'	# Extension for Direct Parent of .IMA files
	[ ! ${DCMEXTENSION} ] && DCMEXTENSION='.IMA' # Extension of DICOM files	
	# Settings for RAM disk
	[ ! ${RAMDISK} ] && RAMDISK='DICOMDB.RAMDISK'
	[ ! ${RAMDISKSIZE} ] && RAMDISKSIZE_MB=8192 
	# [ ! ${GPGCONFIGCHECK} ] && GPGCONFIGCHECK='' && [ ! ${GITCRYPTCHECK} ] && GITCRYPTCHECK=''
	# Default exit setting
	EXIT=''
	echo '  ‚öôÔ∏è ---> declarations complete '
}
# Define Function
function fetchdicom_install(){
	## pre install check
	if [ -f ${DATABASEDIR}/.installed ]; then
		echo "This program appears to have already been installed.  Reinstall? [y/n]" && read response
		if [ "${response}" = 'y' ] || [ "${response}" = 'Y' ]; then
			rm ${DATABASEDIR}/.installed
		elif [ "${response}" = 'n' ] || [ "${response}" = 'n' ]; then
			EXIT=1 && fetchdicom_exit
		else
			echo "${YELLOW} Incorrect response.. try again" && fetchdicom_install
		fi
	fi
	## Begin Install
	# Declare default variables, install dependencies, set up shop
	fetchdicom_declarations
	fetchdicom_dependencies
	fetchdicom_config
	##
	# post install check
	if [ -d ${DATABASEDIR} ] && [ ${EXIT} ] && [ -f ${DATABASECONFIGFILE} ]; then 
		touch ${DATABASEDIR}/.installed
	else
		fetchdicom_config
	fi
	## check for exit signal
	fetchdicom_exit
}
# Define Function
function fetchdicom_config(){
	clear && printf '\e[3J'
	fetchdicom_declarations && fetchdicom_config.status	
	[ -f ${DATABASECONFIGFILE} ] && fetchdicom_config.load ${DATABASECONFIGFILE}
	echo -e "\n${BLUE}üß† üíΩ DICOM Database Configuration:${NC} ${DATABASE}"
	# Show list of configuration items
	echo -e "\n1]\t${DATABASECONFIG}Create/Download Database\n${NC}2]\t${RAMDISKCONFIG}Configure Dedicated RAM Disk \n${NC}3]\t${SSHFSCONFIG}Set up SSHFS For Mounting Remote Server Data\n${NC}4]\t${GREY}Set up ${GPGCONFIG}GNU Privacy Guard Encryption Keys ${GREY}and ${GITCRYPTCONFIG}initialize git-crypt ${GREY}(Recommended)\n\n${NC}(color key: ${GREY}unconfigured/${GREEN}configured${NC})\n\n${NC}Enter line # (1-4) or (s)how/(d)one"
	read response
	# echo '  ‚öôÔ∏è ---> config input '${response}
	if [ "${response}" = '1' ]; then
		fetchdicom_config.database
	elif [ "${response}" = '2' ]; then
		fetchdicom_config.ramdisk
	elif [ "${response}" = '3' ]; then
		fetchdicom_config.sshfs
	elif [ "${response}" = '4' ]; then
		fetchdicom_config.gpg
	elif [ "${response}" = 'd' ] || [ "${response}" = 'done' ]; then
		EXIT=1 && [ -d ${DATABASEDIR} ]
		[ -f ${DATABASECONFIGFILE} ] && fetchdicom_config.write
		fetchdicom_exit
	elif [ "${response}" = 's' ] || [ "${response}" = 'show' ]; then
		if cat ${DATABASECONFIGFILE} | column -t -c 3 -s '#'; then
			read -p "‚èé   to continue" && fetchdicom_config
		else
			echo -e "${YELLOW}Configuration file contents have not been set, please proceed with configuration${NC}" && read -p '‚èé  to continue.. >> ' && fetchdicom_config
		fi
	else
		echo -e "${YELLOW}Incorrect Response, try again" >&2 && read -p "‚èé   to continue"
		fetchdicom_config
	fi
}
# Define Function
function fetchdicom_config.status(){
	DATABASECONFIG=${GREY} # default
	RAMDISKCONFIG=${GREY}  # default
	SSHFSCONFIG=${GREY}
	GPGCONFIG=${GREY}
	GITCRYPTCONFIG=${GREY}
	[ -f ${DATABASEDIR}/${DATABASE}.config ] && DATABASECONFIG=${GREEN} # indicate if database is installed/initialized
	[ "$(mount | grep ${RAMDISK})" ] && RAMDISKCONFIG=${GREEN}  #
	[ "$(mount | grep "${SERVERUSER}@${SERVER}:${REMOTEDICOMDIR}")" ] && SSHFSCONFIG=${GREEN}	
	[ "${GPGCONFIGCHECK}" ] && GPGCONFIG=${GREEN}
	[ "${GITCRYPTCHECK}" ] && GITCRYPTCONFIG=${GREEN}
	echo '  ‚öôÔ∏è ---> status check '
}
# Function Definition
function fetchdicom_config.load(){
    local file=${1}
    while read var; do
		eval ${var}
    done < ${file}
    echo '  ‚öôÔ∏è ---> loading '${1}' into namespace'
}
# Function Definition
function fetchdicom_config.write(){
	if [ ! -f ${DATABASECONFIGFILE} ]; then
		echo -e "${YELLOW}Configuration file ${DATABASECONFIGFILE} does not exist. Please create/get dataset first.  " >&2 && read -p "‚èé   to continue" &&  fetchdicom_config
	fi
cat <<EOF > ${DATABASECONFIGFILE}
export DATABASECONFIGFILE=${DATABASECONFIGFILE} #Location of configuration file
export DATABASE=${DATABASE}	#Nickname of database
export DATABASE_SHARETYPE=${DATABASE_SHARETYPE} #Is database accessible to more than one SERVERUSER?
export DATABASESOURCE=${DATABASESOURCE} #Where did database come from
export DATABASEDIR=${DATABASEDIR} #Where does database live
export DICOMDATADIR=${DICOMDATADIR} #Where is DICOM data
export SERVERUSER=${SERVERUSER} #SERVERUSER for remote server
export SERVER=${SERVER} #Address for remote server
export REMOTEDICOMDIR=${REMOTEDICOMDIR} #Location of data on remote server
export RAMDISK=${RAMDISK} #Name of ram disk
export RAMDISKSIZE_MB=${RAMDISKSIZE_MB} #Size (MB) of ram disk
export IDENTITY=${IDENTITY} #GPG identity
export DCMPARENTDIR=${DCMPARENTDIR}	#Extension for Direct Parent of .IMA files
export DCMEXTENSION=${DCMEXTENSION} #Extension of DICOM files	
EOF
	cd ${DATABASEDIR}
	if git commit -am "${DATABASE} configuration file update"; then
		cd ${CWD}
	else
		echo -e "${YELLOW}Warning: ${NC} no updates were committed..\n\n"
	fi
	# Load the default settings into environment and print them to screen for SERVERUSER to edit
	echo '  ‚öôÔ∏è --->  wrote configuration file to '${DATABASECONFIGFILE}
	fetchdicom_config.load ${DATABASECONFIGFILE}
}
# Function Definition
## Initialize DICOM database
function fetchdicom_database.init(){
	fetchdicom_declarations
	echo -e "\nInitializing ${DATABASE} in ${DATABASEDIR}"
	[ ! -d ${DATABASEDIR} ] && datalad create ${DATABASEDIR} --shared-access="${DATABASE_SHARETYPE}"
	[ ! -d ${DATABASEDIR}/${DATABASE} ] && datalad create ${DATABASEDIR}/${DATABASE} --shared-access="${DATABASE_SHARETYPE}"
	[ ! -f ${DATABASECONFIGFILE} ] && touch ${DATABASECONFIGFILE}
	cd ${DATABASEDIR}
	if git add ${DATABASECONFIGFILE} && git commit -m "${DATABASE} configuration file initialized"; then
		cd ${CWD}
	else
		echo -e "${YELLOW}Warning: ${NC} no updates were committed..\n\n" && EXIT=1 && fetchdicom_exit
	fi
	if datalad add ${DATABASEDIR} && datalad save ${DATABASEDIR}; then
		echo -e "‚òëÔ∏è  ${GREEN}Database installed at local path :: ${DATABASEDIR}/${DATABASE}${NC}" >&2 && read -p "‚èé   to continue"
	else
		echo -e "${RED}Error: ${NC} install of ${DATABASEDIR} failed..\n\n" && EXIT=1 && fetchdicom_exit
	fi
}
# Function Definition
## Download database from source
function fetchdicom_database.get(){
	DATABASESOURCE=${1}
	DATABASE=${2}
	if datalad install --get-data -s ${DATABASESOURCE} ${DATABASEDIR}/${DATABASE}; then
		cd ${DATABASEDIR}/${DATABASE} && git annex sync
	else
		echo -e "${BRED}Unable to retrieve database ${NC}please try again..\n\n" && fetchdicom_config.database
	fi
}
# Function Definition
## 
function fetchdicom_database.build(){
	echo -e "\n‚ùç Building A Version-Controlled & Encrypted Database Index of All DICOM Data in ${r}"
	echo -e "\n‚è≥  Finding All DICOM Parent Directories (*${DCMPARENTDIR}/) in $(tree --du --si -C -D -L 1 ${r})\n\t..this will take a while ‚òïÔ∏è"
	# Find all series and write to file
	find ${r} -type d -name "*${DCMPARENTDIR}" > ${DATABASEDIR}/seriespaths.tsv && git -am "First Commit :: Path to DICOM Parent Directories"
	# Loop across series and parse dicom header
	echo -e "\n\nüß† üî¶ Parsing DICOM Headers for Session Metadata with dcm2niix\n\t..this can also take a long time ‚è≥ ‚è≥"
	parallel -a ${DATABASEDIR}/seriespaths.tsv -k --link --bar dcm2niix -b o -ba n -f '%f_%t' -o ${DATABASEDIR} > /dev/null
	# Insert path to series in json file
	find ${DATABASEDIR} -type f -name '*.json' | parallel -k --link --bar 
}
# Function Definition
function fetchdicom_database.query(){
	echo 'test'
}
# Setup RAM Disk for speedy operations
function fetchdicom_ramdisk(){
	# set your RAM size in block size: ie) # desired megabytes * 2048
	RAMBLOCKSIZE=$(expr ${RAMDISKSIZE_MB} \* 2048)
	[ $(uname) = 'Darwin' ] && diskutil erasevolume HFS+ ${RAMDISK} `hdiutil attach -nomount ram://${RAMBLOCKSIZE}` && RAMDISK='/Volumes/'${RAMDISK}
	[ $(uname) = 'Linux' ] && echo -e "${YELLOW}RAM Disk Database Operations are Not Supported on Linux yet\n\t${NC}- You can contribute to this repo by submitting a pull request for this missing feature" && EXIT=1 && fetchdicom_exit
	# install database on the ram disk
	datalad install --get-data -s ${DATABASEDIR}/${DATABASE} ${RAMDISK}/${DATABASE}
	echo ln -s ${DATABASEDIR}/${DATABASE}.config ${RAMDISK}/${DATABASE}.config
	ln -s ${DATABASEDIR}/${DATABASE}.config ${RAMDISK}/${DATABASE}.config
	echo -e "\nRAM Disk Exists.. syncing with source database"
	cd ${DATABASEDIR}/${DATABASE} && git annex sync && cd ${CWD}
	DATABASEDIR=${RAMDISK} 
}
# Function Definition
##
function fetchdicom_ramdisk.unmount(){
	if [ "$(mount | grep ${RAMDISK})" ]; then
		# First sync everything in database to origin
		if [ -d "$(mount | grep ${RAMDISK} | awk '{print $3}')/${DATABASE}" ];
			cd $(mount | grep ${RAMDISK} | awk '{print $3}')/${DATABASE}; then
			if git annex sync; then
				cd ${CWD}
			else
				echo -e "${BRED}Error: Syncing RAM Disk Working Directory to Database, git annex sync failed in ${RAMDISK}/${DATABASE}" >&2 && EXIT=1 && fetchdicom_exit
			fi
		fi				
		# Now unmount
		if umount $(mount | grep ${RAMDISK} | awk '{print $3}'); then					
			echo -e "${GREEN} Unmount for ${RAMDISK} was successful${NC}"
		else
			echo -e "${YELLOW}Warning: Cannot unmount ${RAMDISK} - trying forceful" >&2
			if diskutil umount force $(mount | grep ${RAMDISK} | awk '{print $3}'); then
				echo -e "${GREEN} Forceful unmount for ${RAMDISK} was successful${NC}"	
			else
				echo -e "${BRED}Error: Cannot unmount ${RAMDISK}" >&2 EXIT=1 && fetchdicom_exit
			fi
			echo -e "\n${GREY}Configuration of Dedicated RAM Disk for Database${NC}\n\nSpeed-optimized database operations can be conducted on a RAM disk partitioned from total available memory.\n"
		fi
	fi	
}
# Define function
function fetchdicom_mountserver(){
	DICOMDATADIR=${DATABASEDIR}/${SERVERUSER}@${SERVER}.DICOMS
	[ ! -d ${DICOMDATADIR} ] && mkdir -p ${DICOMDATADIR} && echo ${DICOMDATADIR} >> .gitignore
	if sshfs ${SERVERUSER}@${SERVER}:${REMOTEDICOMDIR} ${DICOMDATADIR} -o cipher=arcour,kernel_cache,defer_permissions,follow_symlinks,reconnect; then
		SSHFSCONFIG='${GREEN}'
	else
		echo -e "${RED}Error: mount of remote data source failed" && EXIT=1 && fetchdicom_exit
	fi
}
# Function Definition
## Configure New/Existing Databse
function fetchdicom_config.database(){
	clear && printf '\e[3J'
	echo -e "\n${GREY}Database Configuration\n\n${NC}‚Åç A database is defined as a git version-controlled directory managed with the ${BLUE}datalad${NC} utility. \
		\n\n‚Åç A database can be built from scratch given a path to existing data or can be downloaded with ssh/rsync/http protocol.\n\t(note: ${BLUE}'git clone'${NC} command is used to obtain existing data)\
		\n\nWould you like to install an existing database or build a new one from scratch?\n"
	read -p "enter (n)ew, (e)xisting or (q)uit >> " response
	if [ "${response}" = "n" ] || [ "${response}" = "new" ] || [ "${response}" = "N" ] || [ "${response}" = "New" ]; then
		echo -e '\nPlease enter a nickname for this database. e.g.) mydicomdb' && read response
		DATABASE=${response} && DATABASECONFIGFILE='' && fetchdicom_declarations && fetchdicom_database.init && fetchdicom_config.write && fetchdicom_config
	elif [ "${response}" = "e" ] || [ "${response}" = "existing" ] || [ "${response}" = "Existing" ] || [ "${response}" = "E" ] || [ "${response}" = "Exist" ] || [ "${response}" = "exist" ]; then
		echo -e "\nPlease type the path to the existing database.\n\tHint) This can be a full local file path like:\n\t\t'~/folder/mydatabase'\n\tor a remote server path like:\n\t\t'ssh://SERVERUSER@server:22/folder/mydatabase'\nEnter path" && read response
		echo '\nPlease enter a nickname for this database. e.g.) mydicomdb\n' && read secondresponse
		fetchdicom_database.get ${response} ${secondresponse}
	elif [ "${response}" = "q" ]  || [ "${response}" = "Q" ]; then
		fetchdicom_config
	else
		echo -e "${BRED}Incorrect response.. ${NC}please type n/new or e/existing..\n\n" && sleep 1 && fetchdicom_config.database
	fi
}
# Define Function
## Configure RAMDISK
function fetchdicom_config.ramdisk(){
	clear && printf '\e[3J'
	echo -e "\n${GREY}Configuration of Dedicated RAM Disk for Database${NC}\n\nSpeed-optimized database operations can be conducted on a RAM disk partitioned from total available memory.\n"
	# Check if disk is already mounted and present user with options
	if [ "$(mount | grep ${RAMDISK})" ]; then
		# Reconfigure disk?
		echo -e "${YELLOW}Warning: RAM DISK already exists\n\n${NC}Would you like to remove and reconfigure the RAM disk?"
		read -p "(u)nmount/(r)econfigure/(q)uit >> " response
		if [ "${response}" = 'q' ] || [ "${response}" = 'quit' ]; then
			fetchdicom_config
		elif [ "${response}" = 'u' ] || [ "${response}" = 'umnount' ]; then
			fetchdicom_ramdisk.unmount && fetchdicom_config
		elif [ "${response}" = 'r' ] || [ "${response}" = 'reconfigure' ]; then
			echo ".."
		else
			echo -e "${YELLOW}Incorrect Response, try again${NC}" >&2 && read -p "‚èé   to continue"			
			fetchdicom_config.ramdisk
		fi
	fi
	echo -e "\nDefault settings are to create a ${RAMDISKSIZE_MB}MB partition. Would you like to modify this value?" && read -p "y/n/(q)uit>> " response
	if [ "${response}" = 'y' ] || [ "${response}" = 'Y' ]; then
		printf "\r"
		read -p "Enter desired size in Megabyte " RAMDISKSIZE_MB
		if [ "${RAMDISKSIZE_MB}" -eq "${RAMDISKSIZE_MB}" ] 2>/dev/null; then
			fetchdicom_config.write
		else
			echo -e "${YELLOW}Input must be numeric.. ${NC}" && read -p "‚èé   to try again, control + c to quit " && fetchdicom_config.ramdisk	
		fi
	elif [ "${response}" = 'n' ] || [ "${response}" = 'N' ]; then
		echo 'continuing..'
	elif [ "${response}" = 'quit' ] || [ "${response}" = 'q' ] || [ "${response}" = 'Q' ]; then
		echo 'exiting RAM disk configuration' && fetchdicom_config
	else
		echo -e "${BRED}Incorrect response.. ${NC}please type y/n ... n\n" && read -p "‚èé   to continue" && fetchdicom_config.ramdisk
	fi
	# create RAM disk here
	if fetchdicom_ramdisk; then
		RAMDISKCONFIG=${GREEN}
		echo -e "${GREEN}Successful creation of RAM DISK${NC}" && read -p "‚èé   to continue"
	else
		RAMDISKCONFIG=${RED}
		echo -e "${BRED}RAM DISK creation FAILED${NC}\n\n" && read -p "‚èé   to continue"
	fi
	fetchdicom_config
}
# Function Definition
## Configure SSHFS mount
function fetchdicom_config.sshfs(){
	clear && printf '\e[3J'
echo -e "${GREY}Secure Shell FileSystems (SSHFS) Configuration\n\n${NC}‚Åç SSHFS is a tool that allows mounting remote directories unto your local file system. In other words, you can view a folder from a computer across the internet as if it was attached like an external hard drive.\n\n‚Åç To set up SSHFS you will need the ip address (xxx.xxx.xxx.x) or domain name (xxxx.com or xxxx.local) of the remote computer and a SERVERUSER account to log in with on that computer.\n"
read -p "Would you like to continue? (y/n)  >> " response
	if [ "${response}" = y ] || [ "${response}" = Y ]; then
		echo -e "\nPlease enter the remote server address\n  "
		read SERVER
		echo -e "\nPlease enter the SERVERUSER account for the remote server\n  "
		read SERVERUSER
		echo -e "\nEnter the directory on the remote server you would like to mount on your machine\n  "
		read REMOTEDICOMDIR
		fetchdicom_mountserver
	elif [ "${response}" = n ] || [ "${response}" = N ]; then
		echo 'Exiting SSHFS Configuration'
	fi
	fetchdicom_config
}
# Function Definition
## initialize git crypt
function fetchdicom_config.gitcrypt(){
	clear && printf '\e[3J'
	echo -e "\nüîê ${GREY}Configuring Encrypted Version Control"
	echo -e "\n\t- Initializing git crypt..." && cd ${DATABASEDIR}/${DATABASE}
	if git crypt init; then
		echo '*.json filter=git-crypt diff=git-crypt' > .gitattributes
		fetchdicom_config.gpg
		echo -e "\n\t - Adding authorized identity to repository.\nPlease Enter Full fingerprint/SERVERUSERid of Desired Key\n\tSERVERUSER ID example)\t\tJohn Doe <john@doe.com>\n\tFingerprint example)\t\t39CDD01"
		read -s ${IDENTITY}
		if git-crypt add-gpg-SERVERUSER ${IDENTITY}; then
			GITCRYPTCHECK='true'
		else
			echo -e "${RED}Failed to add gpg identity ${IDENTITY} to git crypt" >&2
			EXIT=1 && fetchdicom_exit			
		fi
	else
		echo -e "${RED}Failed Initialization of Git Crypt" >&2
		EXIT=1 && fetchdicom_exit
	fi
}
# Define Function
## Configure Encryption Keys with GNU Privacy Guard
function fetchdicom_config.gpg(){
echo -e "\n#{GREY}GNU Privacy Guard (GPG) Configuration\n\n${NC} GPG is used to manage and create encryption keys unique to your identity. These keys are used to lock any sensitive data within the DICOM database and to prevent unauthorized access.\n\nRead more about GPG and encryption here ::: ${BLUE}https://www.gnupg.org/gph/en/manual.html#INTRO\n\n"
	# Check whether keys exist
	if [ $(gpg --list-keys --keyid-format LONG) ]; then
		printf "\nThe following keys are available on this system:\n\n $(gpg --list-keys --keyid-format LONG)\n\nWould you like to create a new identity (y/n)?"
		read response
	else
		printf "\n\n${BRED}No Encryption Keys Found on This System${NC}\n\nWhat does this mean?\nThe DICOM database cannot be built without an active encryption key due to sensitive data found in the dicom metadata that must be stored for querying by authorized SERVERUSERs. Keys are created and managed with GNU Privacy Guard (https://www.gnupg.org/).\n\nWould you like to create a secure identity with associated keys? (y/n)\n" && read response
	fi
	# Create new key if SERVERUSER desires
	if [ ${response} = "y" ] || [ ${response} = "Y" ]; then
		if gpg --gen-key; then 
			GPGCONFIGCHECK='true'
		else
			EXIT=1 && printf "\n${BRED}\tERROR: ${RED}gpg --genkey failed. ${NC}Cannot proceed without encryption keys\n" >&2 && fetchdicom_exit			
		fi
	elif [ ${response} = "n" ] || [ ${resonse} = "N" ]; then
		# exit if no keys exist and SERVERUSER does not want keys, otherwise echo ''
		if [ ! $(gpg --list-keys --keyid-format LONG) ]; then
			EXIT=1 && printf "\n${BRED}\tERROR: ${NC}Cannot proceed without encryption keys\n" >&2 && fetchdicom_exit
		else
			echo '' 
		fi
	else
		# start over if incorrect input
		printf "\n${RED}\tERROR: ${NC}Incorrect Input ${response}\n" && fetchdicom_gpginit
	fi	
}
# Function Definitions
## Show the help documentation
function fetchdicom_help(){
	clear && printf '\e[3J'
	fetchdicom_declarations
cat <<EOF

	Usage :: ${0##*/}

EOF
}
# Redirect all standard input ($@) to run function and execute program
fetchdicom_run "${OPTIONS}"
#
##